<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="RealAssertions" Id="{4075a3a7-d344-4366-ab18-03d825ecb56e}" SpecialFunc="None">
    <Declaration><![CDATA[(*

short summary
=================
This class provides assert statements for 32 bit floatings (``REAL``).
It implements the interface :ref:`IRealAssertions`

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

methods
==================

*)

{attribute 'reflection'}
FUNCTION_BLOCK INTERNAL RealAssertions EXTENDS AbstactAssertion IMPLEMENTS IRealAssertions
VAR
END_VAR
VAR CONSTANT
	(* mask for determining value as a special value *)
	MASK_FOR_EXPONENT 	:DWORD := 16#7F80_0000;
	(* mask for determining a special value as NaN or infinite *)  
	MASK_FOR_FRACTION	:DWORD := 16#007F_FFFF;
	(* mask to get the sign bit of an infinite or zero value *)
	MASK_FOR_SIGN_BIT	:DWORD := 16#8000_0000;
	(* just to compare results or the memory of a float value *)
	ZERO				:DWORD := 16#0000_0000;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="internal" Id="{dacb2e0d-2ab1-4edf-940d-2e980797670d}" />
    <Property Name="className" Id="{110d9f83-5196-40f7-a8f8-c92f095c55d5}">
      <Declaration><![CDATA[(*

short summary
=================
This abstract property returns the class name of the concrete object, 
It's for debugging purpose

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

PROPERTY className :CNM_AbstractObject.ClassName]]></Declaration>
      <Get Name="Get" Id="{25f10bab-093b-4e1b-a4c8-fc6f9ae1e654}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[className := 'CNM_AssertionInterfaceLib.RealAssertions';
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="isValueInfinite" Id="{5c0faf21-e12e-4e3b-b404-ca440724eab9}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
=================
This method checks if a value is infinite
(infinty OR -inifinity), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================
:return: 
``TRUE``: value is inifinty or -infinity
``FALSE``: value is not inifinty and not -infinity

*)

METHOD PROTECTED isValueInfinite :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword		:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueInfinite := (
	THIS^.isValueSpecial(value)
	AND ((realAsDword^ AND THIS^.MASK_FOR_FRACTION) = THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueNaN" Id="{9d207ed1-76e3-4669-9b89-511934d1b200}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
=================
This method checks if a value is not a number
(NaN), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================
:return: 
``TRUE``: value is NaN
``FALSE``: value is not NaN

*)

METHOD PROTECTED isValueNaN :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword		:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueNaN := (
	THIS^.isValueSpecial(value)
	AND ((realAsDword^ AND THIS^.MASK_FOR_FRACTION) > THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueNegativeInfinite" Id="{423c834a-755b-4204-a989-5f21b9a0c144}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
=================
This method checks if a value is negative infinite
(-inifinity), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================
:return: 
``TRUE``: value is -infinity
``FALSE``: value is not -infinity

*)

METHOD PROTECTED isValueNegativeInfinite : BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword		:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueNegativeInfinite := (
	THIS^.isValueInfinite(value)
	AND ((realAsDword^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.MASK_FOR_SIGN_BIT)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValuePositiveInfinite" Id="{a07bc0f9-f251-4eb2-9854-e41d7804a8d5}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
=================
This method checks if a value is positive infinite
(infinty), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================
:return: 
``TRUE``: value is inifinty
``FALSE``: value is not inifinty

*)

METHOD PROTECTED isValuePositiveInfinite :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword		:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValuePositiveInfinite := (
	THIS^.isValueInfinite(value)
	AND ((realAsDword^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.ZERO)
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="isValueSpecial" Id="{bd6a599f-fefc-4b6a-9b5a-6d06135aa314}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
=================
This method checks if a value is a special value
(NaN OR infinty OR -inifinity), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================
:return: 
``TRUE``: value is inifinty or -infinity or NaN
``FALSE``: value is not inifinty and not -infinity and not NaN

*)

METHOD PROTECTED isValueSpecial :BOOL
VAR_INPUT
	(* value to check *)
	value			:REAL;	
END_VAR
VAR
	(* just to cast the value*)
	realAsDword		:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[realAsDword := ADR(value);
isValueSpecial := ((realAsDword^ AND THIS^.MASK_FOR_EXPONENT) = THIS^.MASK_FOR_EXPONENT);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsANumber" Id="{01a6428d-9f21-45b0-a8c1-d4f5d54065f7}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a number (NOT NaN)
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsANumber
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsANumber'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsEqualTo" Id="{23c83b88-d0da-42e0-955c-a6f47bae0c69}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is equal to the expected value

.. attention:: 
	Nothing is equal to NaN, that means if ``currentValue`` OR ``expectedValue`` OR ``tolerance``
	is NaN then is the assertion false. For details check `IEEE 754`_

.. attention:: 
	infinity is equal to infinity and -infinity is equal to -infinity, that means if
	``currentValue`` AND ``expectedValue`` have the value infinity 
	OR ``currentValue`` AND ``expectedValue`` have the value -infinity
	the assertion is TRUE. For details check `IEEE 754`_

.. attention:: 
	If ``tolerance`` has the value infinity or -infinity and 
	``currentValue`` is not NaN and ``expectedValue`` is not NaN
	then is the assertion true. For details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsEqualTo
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* expected value to compare *)
	expectedValue	:REAL;
	(* tolerance to compensate twiddling floats, it has no sign *)
	tolerance		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue)
	OR THIS^.isValueNaN(expectedValue)
	OR THIS^.isValueNaN(tolerance)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));
ELSIF (THIS^.isValueInfinite(tolerance)) THEN
	RETURN;
ELSIF (
	THIS^.isValueInfinite(currentValue)
	OR THIS^.isValueInfinite(expectedValue)
	OR THIS^.isValueInfinite(tolerance)
) THEN
	RETURN (THIS^.isValuePositiveInfinite(currentValue) AND THIS^.isValuePositiveInfinite(expectedValue));
	RETURN (THIS^.isValueNegativeInfinite(currentValue) AND THIS^.isValueNegativeInfinite(expectedValue));
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));	
ELSIF (ABS(currentValue-expectedValue) > ABS(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsEqualTo'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsFinite" Id="{46d1e6fc-d580-437e-af9d-09737f998478}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is finite
(NOT (infinty OR -inifinity)), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsFinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsFinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsGreaterThan" Id="{729170e6-29b6-428b-a0be-d7a35bb7d079}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is greater than the less value

.. attention:: 
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``lessValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

.. attention:: 
	Every number is smaller than infinity except -infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check `IEEE 754`_ and the truth table below.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

truth table for special values
===============================
+----------------------+-------------------+---------------+
| **``currentValue``** | **``lessValue``** | **assertion** |
+======================+===================+===============+
| NaN                  | Any value         | FASLE         |
+----------------------+-------------------+---------------+
| Any value            | NaN               | FALSE         |
+----------------------+-------------------+---------------+
| infinity             | NOT NaN           | TRUE          |
|                      | NOT infinity      |               |
+----------------------+-------------------+---------------+
| -infinty             | Any value         | FALSE         |
+----------------------+-------------------+---------------+
| Any value            | infinity          | FALSE         |
+----------------------+-------------------+---------------+
| NOT NaN              | -inifinity        | TRUE          |
| NOT -infinity        |                   |               |
+----------------------+-------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsGreaterThan
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* less than lower limit *)
	lessValue		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR THIS^.isValueNaN(lessValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
ELSIF (THIS^.isValueNegativeInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
ELSIF (THIS^.isValuePositiveInfinite(lessValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
ELSIF (THIS^.isValueNegativeInfinite(lessValue)) THEN
	RETURN;
ELSIF (THIS^.isValuePositiveInfinite(currentValue)) THEN
	RETURN;
ELSIF (currentValue <= lessValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsGreaterThan'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsInfinite" Id="{d5eec068-c757-44d3-8c92-1dfab0efd570}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is infinite
(infinty OR -inifinity), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsInRangeOf" Id="{809fdd7b-21c0-4b90-aa38-03282b659c2a}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is inside a limit

.. attention:: 
	limits are included: ``valueIsInRangeOf(3.0, 3.0, 3.0)`` is a true assertion

.. attention:: 
	Any comparsion to NaN is ``FALSE`` that means 
	if ``lowerLimit`` OR ``currentValue`` OR ``upperLimit``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

.. attention:: 
	Every number is smaller than infinity except -infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check `IEEE 754`_ and the truth table below.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

truth table for special values
===============================
+--------------------+----------------------+--------------------+---------------+
| **``lowerLimit``** | **``currentValue``** | **``upperLimit``** | **assertion** |
+====================+======================+====================+===============+
| NaN                | Any value            | Any value          | FASLE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | NaN                  | Any value          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | Any value            | NaN                | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | NOT NaN              | infinity           | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| infinity           | Any value            | -infinity          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| NOT -infinity      | -infinity            | Any value          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| Any value          | infinity             | NOT infinity       | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | -infinity            | -infinity          | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| infinity           | infinity             | infinity           | TRUE          |
+--------------------+----------------------+--------------------+---------------+
| -infinity          | NOT -infinity        | -infinity          | FALSE         |
+--------------------+----------------------+--------------------+---------------+
| infinity           | NOT infinity         | infinity           | FALSE         |
+--------------------+----------------------+--------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsInRangeOf
VAR_INPUT
	(* lower limit for the current value *)
	lowerLimit		:REAL;
	(* current value to check *)
	currentValue	:REAL;
	(* upper limit for the current value *)
	upperLimit		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(lowerLimit) OR THIS^.isValueNaN(currentValue) OR THIS^.isValueNaN(upperLimit)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (THIS^.isValueNegativeInfinite(upperLimit) AND THIS^.isValuePositiveInfinite(lowerLimit)) THEN	
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (THIS^.isValueNegativeInfinite(currentValue) AND (NOT THIS^.isValueNegativeInfinite(lowerLimit))) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (THIS^.isValuePositiveInfinite(currentValue) AND (NOT THIS^.isValuePositiveInfinite(upperLimit))) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (
	THIS^.isValuePositiveInfinite(lowerLimit)
	AND (NOT THIS^.isValuePositiveInfinite(currentValue))
	AND THIS^.isValuePositiveInfinite(upperLimit)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (
	THIS^.isValueNegativeInfinite(lowerLimit)
	AND (NOT THIS^.isValueNegativeInfinite(currentValue))
	AND THIS^.isValueNegativeInfinite(upperLimit)
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
ELSIF (
	THIS^.isValuePositiveInfinite(lowerLimit)
	AND THIS^.isValuePositiveInfinite(currentValue)
	AND THIS^.isValuePositiveInfinite(upperLimit)
) THEN
	RETURN;
ELSIF (
	THIS^.isValueNegativeInfinite(lowerLimit)
	AND THIS^.isValueNegativeInfinite(currentValue)
	AND THIS^.isValueNegativeInfinite(upperLimit)
) THEN
	RETURN;
ELSIF (THIS^.isValueNegativeInfinite(lowerLimit) AND THIS^.isValuePositiveInfinite(upperLimit)) THEN
	RETURN;
ELSIF ((currentValue < lowerLimit) OR (currentValue > upperLimit)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsInRangeOf'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsLessThan" Id="{aaf01ae9-f482-4060-b8bd-362534f1325d}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is greater than the less value

.. attention::
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``greaterValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

.. attention::
	Every number is smaller than infinity except -infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check `IEEE 754`_ and the truth table below.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``greaterValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| infinity             | Any value            | FALSE         |
+----------------------+----------------------+---------------+
| -infinty             | NOT NaN              | TRUE          |
|                      | NOT -infinity        |               |
+----------------------+----------------------+---------------+
| NOT NaN              | infinity             | TRUE          |
| NOT infinity         |                      |               |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsLessThan
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* greater than upper limit *)
	greaterValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR THIS^.isValueNaN(greaterValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
ELSIF (THIS^.isValuePositiveInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
ELSIF (THIS^.isValueNegativeInfinite(greaterValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
ELSIF (THIS^.isValuePositiveInfinite(greaterValue)) THEN
	RETURN;
ELSIF (THIS^.isValueNegativeInfinite(currentValue)) THEN
	RETURN;
ELSIF (currentValue >= greaterValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsLessThan'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsMax" Id="{aa9a09c5-6d33-43ee-8d89-d12cb1966b9d}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is less than or equal to the maximum value

.. attention::
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``maximumValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

.. attention::
	Every number is smaller than infinity except -infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check `IEEE 754`_ and the truth table below.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``maximumValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| NOT NaN              | infinity             | TRUE          |
+----------------------+----------------------+---------------+
| -infinity            | NOT NaN              | TRUE          |
+----------------------+----------------------+---------------+
| infinity             | NOT infinity         | FALSE         |
+----------------------+----------------------+---------------+
| NOT -infinity        | -infinity            | FALSE         |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsMax
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* upper limit for the current value *)
	maximumValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR THIS^.isValueNaN(maximumValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
ELSIF (
	THIS^.isValueNegativeInfinite(maximumValue)
	AND (NOT THIS^.isValueNegativeInfinite(currentValue))
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
ELSIF (
	THIS^.isValuePositiveInfinite(currentValue)
	AND (NOT THIS^.isValuePositiveInfinite(maximumValue))
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
ELSIF (THIS^.isValuePositiveInfinite(maximumValue)) THEN
	RETURN;	
ELSIF (THIS^.isValueNegativeInfinite(currentValue)) THEN
	RETURN;
ELSIF (currentValue > maximumValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMax'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsMin" Id="{e599ad08-8100-44e7-8aa2-e69f18f6038a}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is greater than or equal to the minimum value

.. attention::
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue`` OR ``minimumValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_ and the truth table below.

.. attention::
	Every number is smaller than infinity except -infinity, it's equal.
	Every number is greater than -infinity except -infinity, it's equal.
	For details check `IEEE 754`_ and the truth table below.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

truth table for special values
===============================
+----------------------+----------------------+---------------+
| **``currentValue``** | **``minimumValue``** | **assertion** |
+======================+======================+===============+
| NaN                  | Any value            | FASLE         |
+----------------------+----------------------+---------------+
| Any value            | NaN                  | FALSE         |
+----------------------+----------------------+---------------+
| infinity             | NOT NaN              | TRUE          |
+----------------------+----------------------+---------------+
| NOT NaN              | -infinity            | TRUE          |
+----------------------+----------------------+---------------+
| -infinity            | NOT -infinity        | FALSE         |
+----------------------+----------------------+---------------+
| NOT infinity         | infinity             | FALSE         |
+----------------------+----------------------+---------------+

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsMin
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* lower limit for the current value *)
	minimumValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR THIS^.isValueNaN(minimumValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
ELSIF (
	THIS^.isValueNegativeInfinite(currentValue)
	AND (NOT THIS^.isValueNegativeInfinite(minimumValue))
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
ELSIF (
	THIS^.isValuePositiveInfinite(minimumValue)
	AND (NOT THIS^.isValuePositiveInfinite(currentValue))
) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
ELSIF (THIS^.isValuePositiveInfinite(currentValue)) THEN
	RETURN;	
ELSIF (THIS^.isValueNegativeInfinite(minimumValue)) THEN
	RETURN;
ELSIF (currentValue < minimumValue) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsMin'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNaN" Id="{5ba7face-def7-44ed-a9e2-e3c8d06b9b8b}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a not a number (NaN)
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNaN
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNaN'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegative" Id="{196e3f23-0387-4279-9249-8c52a29112f1}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is negative

.. attention::
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_.

.. attention::
	``currentValue`` has the value infinity means the assertion is false.
	``currentValue`` has the value -infinity means the assertion is true.
	``currentValue`` has the +0.0 means the assertion is false.
	``currentValue`` has the value -0.0 means the assertion is true.	
	For details check `IEEE 754`_.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNegative
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN	
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegative'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegative'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegativeInfinite" Id="{9f3e8c15-3a99-422b-a9f5-cc588575386c}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is negative infinite
(-infinty), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNegativeInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueNegativeInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegativeInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNegativeZero" Id="{9c7eb503-5772-4a80-a6bf-48b6de5759b3}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is +0.0
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNegativeZero
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[currentValueAsDWord := ADR(currentValue);
IF (currentValueAsDWord^ <> THIS^.MASK_FOR_SIGN_BIT) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNegativeZero'));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNormal" Id="{971b583f-77bb-4603-967c-0772d9cfc8b2}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a normal number
(a finite non-zero/non-subnormal floating-point number)
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNormal
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue) OR THIS^.isValueInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNormal'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_EXPONENT) = THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNormal'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotEqualTo" Id="{bb7da86f-a9ed-4972-87e2-da9055c11de9}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is not equal to the unexpected value

.. attention:: 
	Nothing is equal to NaN, that means if ``currentValue`` OR ``unexpectedValue`` OR ``tolerance``
	is NaN then is the assertion true. For details check `IEEE 754`_

.. attention:: 
	infinity is equal to infinity and -infinity is equal to -infinity, that means if
	``currentValue`` AND ``unexpectedValue`` have the value infinity 
	OR ``currentValue`` AND ``unexpectedValue`` have the value -infinity
	the assertion is false. For details check `IEEE 754`_

.. attention:: 
	If ``tolerance`` has the value infinity or -infinity and 
	``currentValue`` is not NaN and ``unexpectedValue`` is not NaN
	then is the assertion false. For details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNotEqualTo
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* unexpected value to compare *)
	unexpectedValue	:REAL;
	(* tolerance to compensate twiddling floats, it has no sign *)
	tolerance		:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (
	THIS^.isValueNaN(currentValue)
	OR THIS^.isValueNaN(unexpectedValue)
	OR THIS^.isValueNaN(tolerance)
) THEN
	RETURN;
ELSIF (THIS^.isValueInfinite(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
ELSIF (
	THIS^.isValueInfinite(currentValue)
	OR THIS^.isValueInfinite(unexpectedValue)
) THEN
	RETURN (THIS^.isValuePositiveInfinite(currentValue) AND (NOT THIS^.isValuePositiveInfinite(unexpectedValue)));
	RETURN (THIS^.isValueNegativeInfinite(currentValue) AND (NOT THIS^.isValueNegativeInfinite(unexpectedValue)));
	RETURN (THIS^.isValuePositiveInfinite(unexpectedValue) AND (NOT THIS^.isValuePositiveInfinite(currentValue)));
	RETURN (THIS^.isValueNegativeInfinite(unexpectedValue) AND (NOT THIS^.isValueNegativeInfinite(currentValue)));
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
ELSIF (ABS(currentValue-unexpectedValue) <= ABS(tolerance)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotEqualTo'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotNegativeInfinite" Id="{a5999cde-df2a-42fa-9686-58d56eb55c8d}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is not negative infinite
NOT (-infinty), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNotNegativeInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNegativeInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotNegativeInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotPositiveInfinite" Id="{0e74a275-4a00-43e4-ac07-0eef8bbfc5ce}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is not positive infinite
NOT (infinty), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNotPositiveInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValuePositiveInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotPositiveInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsNotSpecial" Id="{39d10c28-a17b-4000-87e5-b53205532416}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a non special number
(NOT (NaN OR infinty OR -inifinity)), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsNotSpecial : BOOL
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueSpecial(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsNotSpecial'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositive" Id="{59a0d857-c5f4-4496-bb39-aec683e6c979}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is positve

.. attention::
	Any comparsion to NaN is ``FALSE`` that means if ``currentValue``
	is NaN then is the assertion false.
	For details check `IEEE 754`_.

.. attention::
	``currentValue`` has the value infinity means the assertion is true.
	``currentValue`` has the value -infinity means the assertion is false.
	``currentValue`` has the +0.0 means the assertion is true.
	``currentValue`` has the value -0.0 means the assertion is false.	
	For details check `IEEE 754`_.

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsPositive
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN	
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositive'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_SIGN_BIT) = THIS^.MASK_FOR_SIGN_BIT) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositive'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositiveInfinite" Id="{2e93fe7c-8e54-40ef-a67e-9362199d50a3}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is positive infinite
(infinty), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsPositiveInfinite
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValuePositiveInfinite(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositiveInfinite'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsPositiveZero" Id="{4db29f5b-3a0f-42cc-9bca-74eecdc9ea6e}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is -0.0
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsPositiveZero
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[currentValueAsDWord := ADR(currentValue);
IF (currentValueAsDWord^ <> THIS^.ZERO) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsPositiveZero'));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsSpecial" Id="{fa227a03-0a18-4e65-b42d-1229b9785211}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a special
(NaN OR infinty OR -inifinity), for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsSpecial
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT THIS^.isValueSpecial(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSpecial'));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="valueIsSubnormal" Id="{31dc6de5-ee2e-4578-9a2c-083937389a26}">
      <Declaration><![CDATA[(*

short summary
=================
This assertion method checks if the current value is a subnormal number
for details check `IEEE 754`_

.. _IEEE 754: https://en.wikipedia.org/wiki/IEEE_754

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2023 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
=================

*)

METHOD valueIsSubnormal
VAR_INPUT
	(* current value to check *)
	currentValue	:REAL;
	(* message if the assertion is false *)
	message			:AssertMessage;
END_VAR
VAR
	(* just to cast ``currentValue`` *)
	currentValueAsDWord	:POINTER TO DWORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (THIS^.isValueNaN(currentValue)) THEN
	THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSubnormal'));
ELSE
	currentValueAsDWord := ADR(currentValue);
	IF ((currentValueAsDWord^ AND THIS^.MASK_FOR_EXPONENT) <> THIS^.ZERO) THEN
		THIS^.assertionWasWrong(message, THIS^.getDebugInfo('valueIsSubnormal'));
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RealAssertions">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.className.Get">
      <LineId Id="5" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueInfinite">
      <LineId Id="15" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueNaN">
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="4" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueNegativeInfinite">
      <LineId Id="14" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.isValuePositiveInfinite">
      <LineId Id="14" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.isValueSpecial">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="1" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsANumber">
      <LineId Id="40" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsEqualTo">
      <LineId Id="77" Count="0" />
      <LineId Id="79" Count="2" />
      <LineId Id="78" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="84" Count="4" />
      <LineId Id="90" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="41" Count="1" />
      <LineId Id="40" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsFinite">
      <LineId Id="36" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsGreaterThan">
      <LineId Id="115" Count="5" />
      <LineId Id="122" Count="1" />
      <LineId Id="140" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="36" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsInfinite">
      <LineId Id="36" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsInRangeOf">
      <LineId Id="113" Count="0" />
      <LineId Id="118" Count="1" />
      <LineId Id="145" Count="5" />
      <LineId Id="152" Count="1" />
      <LineId Id="155" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="156" Count="19" />
      <LineId Id="36" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsLessThan">
      <LineId Id="136" Count="3" />
      <LineId Id="141" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsMax">
      <LineId Id="100" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="106" Count="5" />
      <LineId Id="113" Count="3" />
      <LineId Id="101" Count="0" />
      <LineId Id="103" Count="2" />
      <LineId Id="35" Count="2" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsMin">
      <LineId Id="100" Count="1" />
      <LineId Id="105" Count="13" />
      <LineId Id="35" Count="2" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNaN">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegative">
      <LineId Id="83" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="36" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegativeInfinite">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNegativeZero">
      <LineId Id="35" Count="0" />
      <LineId Id="39" Count="2" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNormal">
      <LineId Id="35" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="41" Count="4" />
      <LineId Id="40" Count="0" />
      <LineId Id="47" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotEqualTo">
      <LineId Id="92" Count="5" />
      <LineId Id="109" Count="1" />
      <LineId Id="98" Count="2" />
      <LineId Id="102" Count="2" />
      <LineId Id="111" Count="1" />
      <LineId Id="106" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="39" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotNegativeInfinite">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotPositiveInfinite">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsNotSpecial">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositive">
      <LineId Id="84" Count="7" />
      <LineId Id="32" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositiveInfinite">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsPositiveZero">
      <LineId Id="40" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsSpecial">
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="RealAssertions.valueIsSubnormal">
      <LineId Id="40" Count="7" />
      <LineId Id="35" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>