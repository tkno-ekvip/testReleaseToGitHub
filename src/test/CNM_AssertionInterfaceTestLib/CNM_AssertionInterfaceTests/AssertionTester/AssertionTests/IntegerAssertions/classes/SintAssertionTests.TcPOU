<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="SintAssertionTests" Id="{7343f759-0a3a-4032-9c4d-ab9f57e34525}" SpecialFunc="None">
    <Declaration><![CDATA[(*

short summary
==================
This class tests all methods of sint assertions
with various combinations of inputs and checks expected 
outputs are satisfied or not

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

methods and properties
======================

*)

FUNCTION_BLOCK SintAssertionTests EXTENDS AbstractAssertorTest
VAR_INPUT
END_VAR
VAR CONSTANT
	(* prefix to unify the test names *)
	TEST_NAME_PREFIX	:Tc2_System.T_MaxString := 'assert.integer.signed.short.';
	(* number of the lsb *)
	FIRST_BIT				:USINT := 0;
	(* number of the msb *)
	LAST_BIT				:USINT := 7;
	(* multiplicand for the ``multiplier`` *)
	MULTIPLICAND			:SINT := 16#11;
	(* first of all multipliers the test iterates *)
	FIRST_MULTIPLIER		:SINT := 0;
	(* first of all multipliers the test iterates *)
	LAST_MULTIPLIER			:SINT := 15;
	(* the msb is set only *)
	MINIMUM_VALUE			:SINT := -128;
	(* the msb is unset only *)
	MAXIMUM_VALUE			:SINT := 127;
	(* just the value zero *)
	ZERO					:SINT := 0;
	(* just the lsb is set, it's just the value one *)
	LSB_ONLY				:SINT := 1;
	(* all bits are set *)
	ALL_BITS_SET			:SINT := -1;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[THIS^.runValueIsEqualToTests();
THIS^.runValueIsEvenTests();
THIS^.runValueIsGreaterTests();
THIS^.runValueIsInRangeOfTests();
THIS^.runValueIsLessThanTests();
THIS^.runValueIsMaxTests();
THIS^.runValueIsMinTests();
THIS^.runValueIsNegativeTests();
THIS^.runValueIsNotEqualToTests();
THIS^.runValueIsOddTests();
THIS^.runValueIsPositiveTests();
]]></ST>
    </Implementation>
    <Folder Name="internal" Id="{0fafaa9d-36ff-4573-97b0-8acc0c4dbe54}" />
    <Folder Name="valueIsEqualTo" Id="{6003e48d-cfa0-4458-bfd0-a3a3ea57e32d}" />
    <Folder Name="valueIsEven" Id="{bdaf8146-9a43-486c-86b2-a2449eaf31b2}" />
    <Folder Name="valueIsGreaterThan" Id="{562c3e2d-892c-4ee4-ae97-e992b569611e}" />
    <Folder Name="valueIsInRangeOf" Id="{81173b4f-4eb8-414b-878a-de5f35ec6cb6}" />
    <Folder Name="valueIsLessThan" Id="{36d35445-cfbe-4145-a7b3-7fc37b32bb2c}" />
    <Folder Name="valueIsMax" Id="{e06a3070-e34e-484d-a3f6-b242da53b033}" />
    <Folder Name="valueIsMin" Id="{9eadcdbe-e733-490a-b3bb-0d6d360b58a5}" />
    <Folder Name="valueIsNegative" Id="{d6de64db-db88-404a-9eed-342196b8fdb3}" />
    <Folder Name="valueIsNotEqual" Id="{d451dc41-68fc-43ff-bf2f-397133f47503}" />
    <Folder Name="valueIsOdd" Id="{f238bf96-f214-47d1-a595-eb3b273adb7e}" />
    <Folder Name="valueIsPositive" Id="{bb017fa9-789e-4727-a15a-6a47ec127f7b}" />
    <Method Name="getTestNameFor" Id="{e1f4b55b-5583-48f6-90d9-28e1e6b9f28a}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
==================
This test method is a helper function to create a unified test name

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD PROTECTED getTestNameFor :Tc2_System.T_MaxString
VAR_INPUT
	(* name of the method to test, to create a unified test name *)
	nameOfMethodToTest	:Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getTestNameFor := Tc2_Standard.CONCAT(THIS^.TEST_NAME_PREFIX, nameOfMethodToTest);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsEqualToTests" Id="{782fa5ea-afbe-4d6f-bacd-aede27f022a5}" FolderPath="valueIsEqualTo\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsEqualTo``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsEqualToTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsEqualTo')));

THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ZERO,
	expected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ZERO,
	expected := THIS^.ZERO
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	expected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	expected := THIS^.ZERO
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	expected := THIS^.LSB_ONLY
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	expected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.LSB_ONLY
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.MAXIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsEvenTests" Id="{3dec7e54-00a8-4d0c-9049-1383c588746e}" FolderPath="valueIsEven\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsEven``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsEvenTests
VAR
	(* it's just part of the test data *)
	valueToTest	:SINT;
	(* multiplier to get various bit patterns *)
	multiplier	:SINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsEven')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsEven(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsGreaterTests" Id="{22372d70-0608-4f92-9383-91be19d32dd5}" FolderPath="valueIsGreaterThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsGreaterThan``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsGreaterTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsGreaterThan')));

THIS^.testValueIsGreater(
	valueToTest := THIS^.ZERO,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ZERO,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ALL_BITS_SET,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ALL_BITS_SET,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := THIS^.LSB_ONLY
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := (THIS^.LSB_ONLY+THIS^.LSB_ONLY)
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MAXIMUM_VALUE,
	less := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsInRangeOfTests" Id="{8dcf8f6b-604c-40c5-a898-2352cebab05a}" FolderPath="valueIsInRangeOf\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsInRangeOf``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsInRangeOfTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsInRangeOf')));

THIS^.testValueIsInRangeOf(
	lower := THIS^.ZERO,
	valueToTest := THIS^.LSB_ONLY,
	upper := THIS^.ALL_BITS_SET
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ZERO,
	valueToTest := THIS^.ZERO,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.ALL_BITS_SET,
	upper := THIS^.ALL_BITS_SET
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.LSB_ONLY,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.ZERO,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MAXIMUM_VALUE,
	valueToTest := THIS^.ZERO,
	upper := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.ZERO,
	upper := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MAXIMUM_VALUE,
	valueToTest := THIS^.MINIMUM_VALUE,
	upper := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.MAXIMUM_VALUE,
	upper := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.MINIMUM_VALUE,
	upper := THIS^.MAXIMUM_VALUE
);

TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsLessThanTests" Id="{bb9c0266-bf0d-45de-b473-9e0be53e4ab2}" FolderPath="valueIsLessThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsLessThan``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsLessThanTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsLessThan')));

THIS^.testValueIsLessThan(
	valueToTest := THIS^.ZERO,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ZERO,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ALL_BITS_SET,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ALL_BITS_SET,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.LSB_ONLY,
	greater := THIS^.LSB_ONLY
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.LSB_ONLY,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MAXIMUM_VALUE,
	greater := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsMaxTests" Id="{50d505f3-12bf-4034-a583-051d860483c9}" FolderPath="valueIsMax\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsMax``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsMaxTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsMax')));

THIS^.testValueIsMax(
	valueToTest := THIS^.ZERO,
	maximum := THIS^.LSB_ONLY
);
THIS^.testValueIsMax(
	valueToTest := THIS^.LSB_ONLY,
	maximum := THIS^.ZERO
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ZERO,
	maximum := THIS^.ZERO
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ALL_BITS_SET,
	maximum := ALL_BITS_SET
);
THIS^.testValueIsMax(
	valueToTest := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY),
	maximum := THIS^.ALL_BITS_SET
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ALL_BITS_SET,
	maximum := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY)
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsMax(
	valueToTest := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY),
	maximum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MAXIMUM_VALUE,
	maximum := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsMinTests" Id="{02382336-5afa-425e-ac1e-9dc4c4a39af6}" FolderPath="valueIsMin\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsMin``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsMinTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsMin')));

THIS^.testValueIsMin(
	valueToTest := THIS^.ZERO,
	minimum := THIS^.LSB_ONLY
);
THIS^.testValueIsMin(
	valueToTest := THIS^.LSB_ONLY,
	minimum := THIS^.ZERO
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ZERO,
	minimum := THIS^.ZERO
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ALL_BITS_SET,
	minimum := ALL_BITS_SET
);
THIS^.testValueIsMin(
	valueToTest := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY),
	minimum := THIS^.ALL_BITS_SET
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ALL_BITS_SET,
	minimum := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY)
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsMin(
	valueToTest := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY),
	minimum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MAXIMUM_VALUE,
	minimum := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsNegativeTests" Id="{d5f4b639-6916-4c08-af18-ccfd15518ee0}" FolderPath="valueIsNegative\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsNegative``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsNegativeTests
VAR
	(* it's just part of the test data *)
	valueToTest	:SINT;
	(* multiplier to get various bit patterns *)
	multiplier	:SINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsNegative')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsNegative(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsNotEqualToTests" Id="{e25efe06-024f-43cc-888a-3301137a28c2}" FolderPath="valueIsNotEqual\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsNotEqualTo``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsNotEqualToTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsNotEqualTo')));

THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ZERO,
	unexpected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ZERO,
	unexpected := THIS^.ZERO
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	unexpected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	unexpected := THIS^.ZERO
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	unexpected := THIS^.LSB_ONLY
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	unexpected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.LSB_ONLY
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.MAXIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsOddTests" Id="{1a5ed47f-1b5f-42bb-a67f-1caa8e589dba}" FolderPath="valueIsOdd\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsOdd``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsOddTests
VAR
	(* it's just part of the test data *)
	valueToTest	:SINT;
	(* multiplier to get various bit patterns *)
	multiplier	:SINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsOdd')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsOdd(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsPositiveTests" Id="{97f32aa2-ed60-4a2d-99ef-7513b49dce3e}" FolderPath="valueIsPositive\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsPositive``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsPositiveTests
VAR
	(* it's just part of the test data *)
	valueToTest	:SINT;
	(* multiplier to get various bit patterns *)
	multiplier	:SINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsPositive')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsPositive(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsEqualTo" Id="{47f4a519-9d4c-4523-84ba-4b31df7e3474}" FolderPath="valueIsEqualTo\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsEqualTo``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsEqualTo
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``expectedValue`` *)
	expected	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest <> expected);
message := SEL(
	assertionIsWrong,
	'currentValue is %d expectedValue is %d assertion must be TRUE', 
	'currentValue is %d expectedValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(expected)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsEqualTo(
	currentValue := valueToTest,
	expectedValue := expected,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsEven" Id="{ee8d2eac-2a6f-4d33-a116-1cc3985fc2a2}" FolderPath="valueIsEven\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsEven``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsEven
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest.FIRST_BIT);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsEven(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsGreater" Id="{05cbdb55-b00c-4902-afb7-2c791ed10722}" FolderPath="valueIsGreaterThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsGreaterThan``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsGreater
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``lessValue`` *)
	less		:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest <= less);
message := SEL(
	assertionIsWrong,
	'currentValue is %d lessValue is %d assertion must be TRUE', 
	'currentValue is %d lessValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(less)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsGreaterThan(
	currentValue := valueToTest,
	lessValue := less,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsInRangeOf" Id="{51103e09-e7b5-479f-9a8f-8a06af4b23d4}" FolderPath="valueIsInRangeOf\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsInRangeOf``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsInRangeOf
VAR_INPUT
	(* for the test it's the parameter ``lowerLimit`` *)
	lower		:SINT;
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``upperLimit`` *)
	upper		:SINT;
END_VAR          
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := ((valueToTest < lower) OR (valueToTest > upper)); 

message := SEL(
	assertionIsWrong,
	'lowerLimit is %d currentValue is %d upperLimit is %d assertion must be TRUE', 
	'lowerLimit is %d currentValue is %d upperLimit is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(lower),
	arg2 := THIS^.AnyToArg(valueToTest),
	arg3 := THIS^.AnyToArg(upper)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsInRangeOf(
	lowerLimit := lower,
	currentValue := valueToTest,
	upperLimit := upper,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsLessThan" Id="{64b709d3-9fca-4951-b4c7-a2230071b628}" FolderPath="valueIsLessThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsLessThan``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsLessThan
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``greaterValue`` *)
	greater		:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest >= greater);
message := SEL(
	assertionIsWrong,
	'currentValue is %d greaterValue is %d assertion must be TRUE',
	'currentValue is %d greaterValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(greater)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsLessThan(
	currentValue := valueToTest,
	greaterValue := greater,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsMax" Id="{09f3465e-4048-433f-a5aa-09b2f8de4763}" FolderPath="valueIsMax\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsMax``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsMax 
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``maximumValue`` *)
	maximum		:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest > maximum);
message := SEL(
	assertionIsWrong,
	'currentValue is %d maximumValue is %d assertion must be TRUE',
	'currentValue is %d maximumValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(maximum)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsMax(
	currentValue := valueToTest,
	maximumValue := maximum,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsMin" Id="{44138ba5-ba43-4f9a-b7f9-7e0145ce6941}" FolderPath="valueIsMin\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsMin``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsMin 
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``minimumValue`` *)
	minimum		:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest < minimum);
message := SEL(
	assertionIsWrong,
	'currentValue is %d minimumValue is %d assertion must be TRUE',
	'currentValue is %d minimumValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(minimum)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsMin(
	currentValue := valueToTest,
	minimumValue := minimum,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsNegative" Id="{f7764b95-cd93-47e8-9d35-b18c19d092d2}" FolderPath="valueIsNegative\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsNegative``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsNegative
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest >= THIS^.ZERO);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsNegative(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsNotEqualTo" Id="{22169334-0ba9-44f7-896f-74f94bfae9bb}" FolderPath="valueIsNotEqual\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsNotEqualTo``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsNotEqualTo
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
	(* for the test it's the parameter ``unexpectedValue`` *)
	unexpected	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest = unexpected);
message := SEL(
	assertionIsWrong,
	'currentValue is %d unexpectedValue is %d assertion must be TRUE', 
	'currentValue is %d unexpectedValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(unexpected)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsNotEqualTo(
	currentValue := valueToTest,
	unexpectedValue := unexpected,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsOdd" Id="{56041e63-8a5f-4cb0-b67f-70158b80fc0c}" FolderPath="valueIsOdd\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsOdd``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsOdd
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (NOT valueToTest.FIRST_BIT);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsOdd(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsPositive" Id="{2364c8c2-952d-408d-b490-613a8bafb950}" FolderPath="valueIsPositive\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.short.valueIsPositive``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsPositive
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:SINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest < THIS^.ZERO);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.short.valueIsPositive(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="SintAssertionTests">
      <LineId Id="36" Count="0" />
      <LineId Id="104" Count="9" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.getTestNameFor">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsEqualToTests">
      <LineId Id="101" Count="33" />
      <LineId Id="159" Count="3" />
      <LineId Id="135" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsEvenTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsGreaterTests">
      <LineId Id="3" Count="1" />
      <LineId Id="67" Count="23" />
      <LineId Id="102" Count="2" />
      <LineId Id="101" Count="0" />
      <LineId Id="91" Count="3" />
      <LineId Id="105" Count="2" />
      <LineId Id="99" Count="0" />
      <LineId Id="131" Count="7" />
      <LineId Id="130" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsInRangeOfTests">
      <LineId Id="3" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="17" />
      <LineId Id="69" Count="0" />
      <LineId Id="88" Count="3" />
      <LineId Id="11" Count="0" />
      <LineId Id="115" Count="9" />
      <LineId Id="147" Count="14" />
      <LineId Id="12" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsLessThanTests">
      <LineId Id="3" Count="1" />
      <LineId Id="67" Count="31" />
      <LineId Id="103" Count="3" />
      <LineId Id="130" Count="7" />
      <LineId Id="107" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsMaxTests">
      <LineId Id="3" Count="0" />
      <LineId Id="64" Count="4" />
      <LineId Id="73" Count="3" />
      <LineId Id="107" Count="2" />
      <LineId Id="106" Count="0" />
      <LineId Id="77" Count="7" />
      <LineId Id="111" Count="2" />
      <LineId Id="110" Count="0" />
      <LineId Id="89" Count="7" />
      <LineId Id="117" Count="0" />
      <LineId Id="102" Count="2" />
      <LineId Id="140" Count="7" />
      <LineId Id="105" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsMinTests">
      <LineId Id="3" Count="0" />
      <LineId Id="63" Count="32" />
      <LineId Id="100" Count="3" />
      <LineId Id="132" Count="7" />
      <LineId Id="104" Count="1" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsNegativeTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsNotEqualToTests">
      <LineId Id="98" Count="33" />
      <LineId Id="156" Count="3" />
      <LineId Id="132" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsOddTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.runValueIsPositiveTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsEqualTo">
      <LineId Id="108" Count="0" />
      <LineId Id="110" Count="10" />
      <LineId Id="122" Count="2" />
      <LineId Id="128" Count="0" />
      <LineId Id="136" Count="1" />
      <LineId Id="129" Count="6" />
      <LineId Id="61" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsEven">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsGreater">
      <LineId Id="69" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsInRangeOf">
      <LineId Id="2" Count="0" />
      <LineId Id="81" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="85" Count="3" />
      <LineId Id="83" Count="0" />
      <LineId Id="90" Count="5" />
      <LineId Id="84" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="4" />
      <LineId Id="97" Count="4" />
      <LineId Id="96" Count="0" />
      <LineId Id="102" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsLessThan">
      <LineId Id="70" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsMax">
      <LineId Id="70" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="94" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsMin">
      <LineId Id="69" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsNegative">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsNotEqualTo">
      <LineId Id="70" Count="24" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsOdd">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="SintAssertionTests.testValueIsPositive">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>