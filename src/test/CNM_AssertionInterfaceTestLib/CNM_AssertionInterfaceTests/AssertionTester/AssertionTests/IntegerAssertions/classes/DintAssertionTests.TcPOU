<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="DintAssertionTests" Id="{943a2126-67cb-4f29-b4b1-8fe9932f62e0}" SpecialFunc="None">
    <Declaration><![CDATA[(*

short summary
==================
This class tests all methods of dint assertions
with various combinations of inputs and checks expected 
outputs are satisfied or not

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

methods and properties
======================

*)

FUNCTION_BLOCK DintAssertionTests EXTENDS AbstractAssertorTest
VAR_INPUT
END_VAR
VAR CONSTANT
	(* prefix to unify the test names *)
	TEST_NAME_PREFIX	:Tc2_System.T_MaxString := 'assert.integer.signed.double.';
	(* number of the lsb *)
	FIRST_BIT				:USINT := 0;
	(* number of the msb *)
	LAST_BIT				:USINT := 7;
	(* multiplicand for the ``multiplier`` *)
	MULTIPLICAND			:DINT := 16#1111_1111;
	(* first of all multipliers the test iterates *)
	FIRST_MULTIPLIER		:DINT := 0;
	(* first of all multipliers the test iterates *)
	LAST_MULTIPLIER			:DINT := 15;
	(* the msb is set only *)
	MINIMUM_VALUE			:DINT := 16#8000_0000;
	(* the msb is unset only *)
	MAXIMUM_VALUE			:DINT := 16#7FFF_FFFF;
	(* just the value zero *)
	ZERO					:DINT := 0;
	(* just the lsb is set, it's just the value one *)
	LSB_ONLY				:DINT := 1;
	(* all bits are set *)
	ALL_BITS_SET			:DINT := -1;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[THIS^.runValueIsEqualToTests();
THIS^.runValueIsEvenTests();
THIS^.runValueIsGreaterTests();
THIS^.runValueIsInRangeOfTests();
THIS^.runValueIsLessThanTests();
THIS^.runValueIsMaxTests();
THIS^.runValueIsMinTests();
THIS^.runValueIsNegativeTests();
THIS^.runValueIsNotEqualToTests();
THIS^.runValueIsOddTests();
THIS^.runValueIsPositiveTests();
]]></ST>
    </Implementation>
    <Folder Name="internal" Id="{68f72109-e164-4c95-894a-d83e21f5d112}" />
    <Folder Name="valueIsEqualTo" Id="{63e0fbba-25d5-4b12-9de3-7f47c9be8e95}" />
    <Folder Name="valueIsEven" Id="{58ac0510-261d-4ff7-97c4-14f3733cf032}" />
    <Folder Name="valueIsGreaterThan" Id="{c8198ce2-e722-44f6-b6f3-f7e921cf89ac}" />
    <Folder Name="valueIsInRangeOf" Id="{7fdad048-6587-428b-8453-87e196321be9}" />
    <Folder Name="valueIsLessThan" Id="{65ba44b8-98ff-426f-8fa2-0ad3bb46d489}" />
    <Folder Name="valueIsMax" Id="{95abf4b2-f8ed-444a-9788-b42edfbc39ea}" />
    <Folder Name="valueIsMin" Id="{d2ac006e-88df-4a59-8d0d-9673324609d4}" />
    <Folder Name="valueIsNegative" Id="{b5206f07-ecbd-4e59-a906-167531bfb6e0}" />
    <Folder Name="valueIsNotEqual" Id="{699cbb3b-af4b-46fc-a8c4-410e218c814a}" />
    <Folder Name="valueIsOdd" Id="{db5a1b51-44ae-42a3-803b-e7a4c0cce34d}" />
    <Folder Name="valueIsPositive" Id="{7c0f57cd-5939-4fa8-8253-e3dff6ab3120}" />
    <Method Name="getTestNameFor" Id="{2475c5d7-c703-40fc-bb5f-185a2b98a172}" FolderPath="internal\">
      <Declaration><![CDATA[(*

short summary
==================
This test method is a helper function to create a unified test name

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD PROTECTED getTestNameFor :Tc2_System.T_MaxString
VAR_INPUT
	(* name of the method to test, to create a unified test name *)
	nameOfMethodToTest	:Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getTestNameFor := Tc2_Standard.CONCAT(THIS^.TEST_NAME_PREFIX, nameOfMethodToTest);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsEqualToTests" Id="{6b4f0296-433f-4672-905b-db04764696a2}" FolderPath="valueIsEqualTo\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsEqualTo``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsEqualToTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsEqualTo')));

THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ZERO,
	expected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ZERO,
	expected := THIS^.ZERO
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	expected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	expected := THIS^.ZERO
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	expected := THIS^.LSB_ONLY
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	expected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.LSB_ONLY
);
THIS^.testValueIsEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	expected := THIS^.MAXIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsEvenTests" Id="{a3acef58-2bcf-48a3-9474-571f781c0de4}" FolderPath="valueIsEven\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsEven``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsEvenTests
VAR
	(* it's just part of the test data *)
	valueToTest	:DINT;
	(* multiplier to get various bit patterns *)
	multiplier	:DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsEven')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsEven(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsGreaterTests" Id="{d234d550-36cf-402c-a946-1812ff72dd93}" FolderPath="valueIsGreaterThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsGreaterThan``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsGreaterTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsGreaterThan')));

THIS^.testValueIsGreater(
	valueToTest := THIS^.ZERO,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ZERO,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ALL_BITS_SET,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.ALL_BITS_SET,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := THIS^.LSB_ONLY
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := THIS^.ZERO
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.LSB_ONLY,
	less := (THIS^.LSB_ONLY+THIS^.LSB_ONLY)
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.ALL_BITS_SET
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MINIMUM_VALUE,
	less := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsGreater(
	valueToTest := THIS^.MAXIMUM_VALUE,
	less := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsInRangeOfTests" Id="{69419760-1608-4338-b3da-c30ddf87642b}" FolderPath="valueIsInRangeOf\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsInRangeOf``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsInRangeOfTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsInRangeOf')));

THIS^.testValueIsInRangeOf(
	lower := THIS^.ZERO,
	valueToTest := THIS^.LSB_ONLY,
	upper := THIS^.ALL_BITS_SET
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ZERO,
	valueToTest := THIS^.ZERO,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.ALL_BITS_SET,
	upper := THIS^.ALL_BITS_SET
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.LSB_ONLY,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.ALL_BITS_SET,
	valueToTest := THIS^.ZERO,
	upper := THIS^.ZERO
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MAXIMUM_VALUE,
	valueToTest := THIS^.ZERO,
	upper := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.ZERO,
	upper := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MAXIMUM_VALUE,
	valueToTest := THIS^.MINIMUM_VALUE,
	upper := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.MAXIMUM_VALUE,
	upper := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsInRangeOf(
	lower := THIS^.MINIMUM_VALUE,
	valueToTest := THIS^.MINIMUM_VALUE,
	upper := THIS^.MAXIMUM_VALUE
);

TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsLessThanTests" Id="{56251697-6d7f-4dfa-9786-ed34c753a1f7}" FolderPath="valueIsLessThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsLessThan``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsLessThanTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsLessThan')));

THIS^.testValueIsLessThan(
	valueToTest := THIS^.ZERO,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ZERO,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ALL_BITS_SET,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.ALL_BITS_SET,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.LSB_ONLY,
	greater := THIS^.LSB_ONLY
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.LSB_ONLY,
	greater := THIS^.ZERO
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.ALL_BITS_SET
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MINIMUM_VALUE,
	greater := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsLessThan(
	valueToTest := THIS^.MAXIMUM_VALUE,
	greater := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsMaxTests" Id="{e038dffd-bf22-4107-b33a-9a71ae32b0e3}" FolderPath="valueIsMax\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsMax``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsMaxTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsMax')));

THIS^.testValueIsMax(
	valueToTest := THIS^.ZERO,
	maximum := THIS^.LSB_ONLY
);
THIS^.testValueIsMax(
	valueToTest := THIS^.LSB_ONLY,
	maximum := THIS^.ZERO
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ZERO,
	maximum := THIS^.ZERO
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ALL_BITS_SET,
	maximum := ALL_BITS_SET
);
THIS^.testValueIsMax(
	valueToTest := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY),
	maximum := THIS^.ALL_BITS_SET
);
THIS^.testValueIsMax(
	valueToTest := THIS^.ALL_BITS_SET,
	maximum := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY)
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsMax(
	valueToTest := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY),
	maximum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MINIMUM_VALUE,
	maximum := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsMax(
	valueToTest := THIS^.MAXIMUM_VALUE,
	maximum := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsMinTests" Id="{cb1a948b-b4cc-4965-8e93-aeb84b5b247e}" FolderPath="valueIsMin\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsMin``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsMinTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsMin')));

THIS^.testValueIsMin(
	valueToTest := THIS^.ZERO,
	minimum := THIS^.LSB_ONLY
);
THIS^.testValueIsMin(
	valueToTest := THIS^.LSB_ONLY,
	minimum := THIS^.ZERO
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ZERO,
	minimum := THIS^.ZERO
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ALL_BITS_SET,
	minimum := ALL_BITS_SET
);
THIS^.testValueIsMin(
	valueToTest := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY),
	minimum := THIS^.ALL_BITS_SET
);
THIS^.testValueIsMin(
	valueToTest := THIS^.ALL_BITS_SET,
	minimum := (THIS^.ALL_BITS_SET-THIS^.LSB_ONLY)
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY)
);
THIS^.testValueIsMin(
	valueToTest := (THIS^.MINIMUM_VALUE+THIS^.LSB_ONLY),
	minimum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MINIMUM_VALUE,
	minimum := THIS^.MAXIMUM_VALUE
);
THIS^.testValueIsMin(
	valueToTest := THIS^.MAXIMUM_VALUE,
	minimum := THIS^.MINIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsNegativeTests" Id="{32665166-77cc-4e0a-b61c-132bb371eef7}" FolderPath="valueIsNegative\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsNegative``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsNegativeTests
VAR
	(* it's just part of the test data *)
	valueToTest	:DINT;
	(* multiplier to get various bit patterns *)
	multiplier	:DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsNegative')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsNegative(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsNotEqualToTests" Id="{003013d8-19e2-49c1-9cab-fe4af92df97c}" FolderPath="valueIsNotEqual\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsNotEqualTo``
method of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsNotEqualToTests
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsNotEqualTo')));

THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ZERO,
	unexpected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ZERO,
	unexpected := THIS^.ZERO
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	unexpected := THIS^.ALL_BITS_SET
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.ALL_BITS_SET,
	unexpected := THIS^.ZERO
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	unexpected := THIS^.LSB_ONLY
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.LSB_ONLY,
	unexpected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.MINIMUM_VALUE
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.LSB_ONLY
);
THIS^.testValueIsNotEqualTo(
	valueToTest := THIS^.MINIMUM_VALUE,
	unexpected := THIS^.MAXIMUM_VALUE
);

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsOddTests" Id="{ce5481fc-8a59-42f9-b033-cb9230e3052e}" FolderPath="valueIsOdd\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsOdd``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsOddTests
VAR
	(* it's just part of the test data *)
	valueToTest	:DINT;
	(* multiplier to get various bit patterns *)
	multiplier	:DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsOdd')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsOdd(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="runValueIsPositiveTests" Id="{eefbd71d-f854-4ed2-89e1-b8ee3bb7a20c}" FolderPath="valueIsPositive\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsPositive``
of CNM_AssertionInterfaceLib library with various inputs

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

*)

METHOD runValueIsPositiveTests
VAR
	(* it's just part of the test data *)
	valueToTest	:DINT;
	(* multiplier to get various bit patterns *)
	multiplier	:DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[RETURN (NOT TcUnit.TEST_ORDERED(THIS^.getTestNameFor('valueIsPositive')));

FOR multiplier := THIS^.FIRST_MULTIPLIER TO THIS^.LAST_MULTIPLIER DO
	valueToTest := (THIS^.MULTIPLICAND * multiplier);
	THIS^.testValueIsPositive(
		valueToTest := valueToTest
	);
END_FOR

TcUnit.TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsEqualTo" Id="{da56e57a-19a1-406c-80d3-5ef84fc84230}" FolderPath="valueIsEqualTo\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsEqualTo``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsEqualTo
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``expectedValue`` *)
	expected	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest <> expected);
message := SEL(
	assertionIsWrong,
	'currentValue is %d expectedValue is %d assertion must be TRUE', 
	'currentValue is %d expectedValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(expected)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsEqualTo(
	currentValue := valueToTest,
	expectedValue := expected,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsEven" Id="{deaf7f8c-901d-48f8-a25f-99b416e39e9a}" FolderPath="valueIsEven\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsEven``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsEven
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest.FIRST_BIT);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsEven(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsGreater" Id="{dd193b1e-82e9-4236-84ce-b1759685da86}" FolderPath="valueIsGreaterThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsGreaterThan``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsGreater
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``lessValue`` *)
	less		:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest <= less);
message := SEL(
	assertionIsWrong,
	'currentValue is %d lessValue is %d assertion must be TRUE', 
	'currentValue is %d lessValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(less)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsGreaterThan(
	currentValue := valueToTest,
	lessValue := less,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsInRangeOf" Id="{890c8abb-de81-45f6-92ad-f9a53b6a4ede}" FolderPath="valueIsInRangeOf\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsInRangeOf``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsInRangeOf
VAR_INPUT
	(* for the test it's the parameter ``lowerLimit`` *)
	lower		:DINT;
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``upperLimit`` *)
	upper		:DINT;
END_VAR          
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := ((valueToTest < lower) OR (valueToTest > upper)); 

message := SEL(
	assertionIsWrong,
	'lowerLimit is %d currentValue is %d upperLimit is %d assertion must be TRUE', 
	'lowerLimit is %d currentValue is %d upperLimit is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(lower),
	arg2 := THIS^.AnyToArg(valueToTest),
	arg3 := THIS^.AnyToArg(upper)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsInRangeOf(
	lowerLimit := lower,
	currentValue := valueToTest,
	upperLimit := upper,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsLessThan" Id="{efddde4d-9fac-454f-a50f-a8405fd084e9}" FolderPath="valueIsLessThan\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsLessThan``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsLessThan
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``greaterValue`` *)
	greater		:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest >= greater);
message := SEL(
	assertionIsWrong,
	'currentValue is %d greaterValue is %d assertion must be TRUE',
	'currentValue is %d greaterValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(greater)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsLessThan(
	currentValue := valueToTest,
	greaterValue := greater,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsMax" Id="{b07e6c4a-dcf7-4cc8-8e03-668ddb42dc00}" FolderPath="valueIsMax\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsMax``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsMax 
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``maximumValue`` *)
	maximum		:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest > maximum);
message := SEL(
	assertionIsWrong,
	'currentValue is %d maximumValue is %d assertion must be TRUE',
	'currentValue is %d maximumValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(maximum)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsMax(
	currentValue := valueToTest,
	maximumValue := maximum,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsMin" Id="{69661513-979e-47e9-9321-f634935026be}" FolderPath="valueIsMin\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsMin``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsMin 
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``minimumValue`` *)
	minimum		:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest < minimum);
message := SEL(
	assertionIsWrong,
	'currentValue is %d minimumValue is %d assertion must be TRUE',
	'currentValue is %d minimumValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(minimum)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsMin(
	currentValue := valueToTest,
	minimumValue := minimum,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsNegative" Id="{f6448c2f-93ae-40e7-bb98-507e9ab08b86}" FolderPath="valueIsNegative\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsNegative``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsNegative
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest >= THIS^.ZERO);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsNegative(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsNotEqualTo" Id="{20b28636-8868-489c-bcfd-85c4879e5dbb}" FolderPath="valueIsNotEqual\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsNotEqualTo``
method of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsNotEqualTo
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
	(* for the test it's the parameter ``unexpectedValue`` *)
	unexpected	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest = unexpected);
message := SEL(
	assertionIsWrong,
	'currentValue is %d unexpectedValue is %d assertion must be TRUE', 
	'currentValue is %d unexpectedValue is %d assertion must be FALSE'
);
messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest),
	arg2 := THIS^.AnyToArg(unexpected)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsNotEqualTo(
	currentValue := valueToTest,
	unexpectedValue := unexpected,
	message := ''
);

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsOdd" Id="{b3b1a59f-5436-4b9a-b41f-9e14758bd48b}" FolderPath="valueIsOdd\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsOdd``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsOdd
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (NOT valueToTest.FIRST_BIT);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsOdd(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="testValueIsPositive" Id="{0932a9ed-e596-4276-9f18-63242a16c004}" FolderPath="valueIsPositive\">
      <Declaration><![CDATA[(*

short summary
==================
This test method tests ``assert.integer.signed.double.valueIsPositive``
of CNM_AssertionInterfaceLib library, 
it provides the possibility to handover test data via parameter 


.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2022 ekvip automation GmbH <info@ekvip.de>
| SPDX-License-Identifier: Apache-2.0
| For details check: Apache-2.0_

.. _Apache-2.0: https://www.apache.org/licenses/LICENSE-2.0

.. </legal notes>

parameters
==========

*)

METHOD testValueIsPositive
VAR_INPUT
	(* for the test it's the parameter ``currentValue`` *)
	valueToTest	:DINT;
END_VAR
VAR
	(* just the expectation if the assertion to test must be worng or true *)
	assertionIsWrong		:BOOL;
	(* contains the format string for the test message *)
	message					:Tc2_System.T_MaxString;
	(* TwinCAT printf with the test message *)
	messageStringBuilder	:Tc2_Utilities.FB_FormatString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.assertorContainer.resetAssertor();

assertionIsWrong := (valueToTest < THIS^.ZERO);

message := SEL(
	assertionIsWrong,
	'currentValue is %d assertion must be TRUE',
	'currentValue is %d assertion must be FALSE'
);

messageStringBuilder(
	sFormat := message,
	arg1 := THIS^.AnyToArg(valueToTest)
);

THIS^.assertorContainer.assertor.assert.integer.signed.double.valueIsPositive(
	currentValue 	:= valueToTest,
	message			:= ''  
); 

THIS^.AssertEquals_BOOL(
	Expected 	:= assertionIsWrong,
	Actual 		:= THIS^.assertorContainer.wasAssertionWrong,
	Message 	:= messageStringBuilder.sOut
);

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="DintAssertionTests">
      <LineId Id="36" Count="0" />
      <LineId Id="104" Count="9" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.getTestNameFor">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsEqualToTests">
      <LineId Id="101" Count="33" />
      <LineId Id="159" Count="3" />
      <LineId Id="135" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsEvenTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsGreaterTests">
      <LineId Id="3" Count="1" />
      <LineId Id="67" Count="23" />
      <LineId Id="102" Count="2" />
      <LineId Id="101" Count="0" />
      <LineId Id="91" Count="3" />
      <LineId Id="105" Count="2" />
      <LineId Id="99" Count="0" />
      <LineId Id="131" Count="7" />
      <LineId Id="130" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsInRangeOfTests">
      <LineId Id="3" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="17" />
      <LineId Id="69" Count="0" />
      <LineId Id="88" Count="3" />
      <LineId Id="11" Count="0" />
      <LineId Id="115" Count="9" />
      <LineId Id="147" Count="14" />
      <LineId Id="12" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsLessThanTests">
      <LineId Id="3" Count="1" />
      <LineId Id="67" Count="31" />
      <LineId Id="103" Count="3" />
      <LineId Id="130" Count="7" />
      <LineId Id="107" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsMaxTests">
      <LineId Id="3" Count="0" />
      <LineId Id="64" Count="4" />
      <LineId Id="73" Count="3" />
      <LineId Id="107" Count="2" />
      <LineId Id="106" Count="0" />
      <LineId Id="77" Count="7" />
      <LineId Id="111" Count="2" />
      <LineId Id="110" Count="0" />
      <LineId Id="89" Count="7" />
      <LineId Id="117" Count="0" />
      <LineId Id="102" Count="2" />
      <LineId Id="140" Count="7" />
      <LineId Id="105" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsMinTests">
      <LineId Id="3" Count="0" />
      <LineId Id="63" Count="32" />
      <LineId Id="100" Count="3" />
      <LineId Id="132" Count="7" />
      <LineId Id="104" Count="1" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsNegativeTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsNotEqualToTests">
      <LineId Id="98" Count="33" />
      <LineId Id="156" Count="3" />
      <LineId Id="132" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsOddTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.runValueIsPositiveTests">
      <LineId Id="64" Count="1" />
      <LineId Id="125" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="37" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsEqualTo">
      <LineId Id="108" Count="0" />
      <LineId Id="110" Count="10" />
      <LineId Id="122" Count="2" />
      <LineId Id="128" Count="0" />
      <LineId Id="136" Count="1" />
      <LineId Id="129" Count="6" />
      <LineId Id="61" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsEven">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsGreater">
      <LineId Id="69" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsInRangeOf">
      <LineId Id="2" Count="0" />
      <LineId Id="81" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="85" Count="3" />
      <LineId Id="83" Count="0" />
      <LineId Id="90" Count="5" />
      <LineId Id="84" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="4" />
      <LineId Id="97" Count="4" />
      <LineId Id="96" Count="0" />
      <LineId Id="102" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsLessThan">
      <LineId Id="70" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsMax">
      <LineId Id="70" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="94" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsMin">
      <LineId Id="69" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsNegative">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsNotEqualTo">
      <LineId Id="70" Count="24" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsOdd">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DintAssertionTests.testValueIsPositive">
      <LineId Id="88" Count="23" />
      <LineId Id="38" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>